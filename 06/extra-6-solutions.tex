\input ../setup

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{tikz-qtree}
\usepackage{amsmath}
\usepackage{amssymb}

% \renewcommand{\labelenumi}{\alph{enumi}.}
% \renewcommand{\labelenumii}{(\roman{enumii})}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}


\lstdefinestyle{normalPy}{
language=Python,				% the language of the code
basicstyle=\footnotesize,			% the size of the fonts that are used for the code
numbers=left,				% where to put the line-numbers; possible values are (none, left, right)
numberstyle=\color{mygray},		% the style that is used for the line-numbers
stepnumber=1,				% the step between two line-numbers. If it's 1, each line will be numbered
numbersep=5pt,				% how far the line-numbers are from the code
backgroundcolor=\color{white},		% choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
showstringspaces=false,			% underline spaces within strings only
showspaces=false,				% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showtabs=false,				% show tabs within strings adding particular underscores
frame=shadowbox,				% adds a frame around the code
tabsize=4,					% sets default tabsize to 4 spaces
captionpos=t,				% sets the caption-position to bottom
breaklines=true,				% sets automatic line breaking
breakatwhitespace=false,			% sets if automatic breaks should only happen at whitespace
commentstyle=\color{mygreen},    	% comment style
keepspaces=true,                 		% keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue},       		% keyword style
}

\lstdefinestyle{consolePy}{
stepnumber=0,
}
\tikzset{every tree node/.style={minimum width=2em,draw,circle},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw, edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
         level distance=1.5cm}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\psetheader{Extra Practice 6 Solutions}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\medskip

For Questions 1-6, what are the output(s) of the code?
\section{Question 1}
\begin{python}
a = [1, 2, 0, 4, 5, 6]

for i in range(len(a)):
    if a[i] % 2 == 0:
        a.pop(i)
    print(a)
\end{python}
\textbf{Solution:}
\begin{python}
[1, 2, 0, 4, 5, 6]
[1, 0, 4, 5, 6]
[1, 0, 5, 6]
[1, 0, 5]
IndexError: list index out of range
\end{python}
Click \href{https://pythontutor.com/visualize.html#code=a%20%3D%20%5B1,%202,%200,%204,%205,%206%5D%0A%0Afor%20i%20in%20range%28len%28a%29%29%3A%0A%20%20%20%20if%20a%5Bi%5D%20%25%202%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20a.pop%28i%29%0A%20%20%20%20print%28a%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false}{\underline{here}} for full visualization.

\section{Question 2}
\begin{python}
a = []

temp = [0]*4
for i in range(3):
    a.append(temp)

a[1][1] = 99
print(a) # [[0, 99, 0, 0], [0, 99, 0, 0], [0, 99, 0, 0]]
\end{python}
Click \href{https://pythontutor.com/visualize.html#code=a%20%3D%20%5B%5D%0A%0Atemp%20%3D%20%5B0%5D*4%0Afor%20i%20in%20range%283%29%3A%0A%20%20%20%20a.append%28temp%29%0A%0Aa%5B1%5D%5B1%5D%20%3D%2099%0Aprint%28a%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false}{\underline{here}} for full visualization.

\section{Question 3}
\begin{python}
a = [1, 2, 3]
b = (1, 2, 3, a, 4, 5)
print(b) # (1, 2, 3, [1, 2, 3], 4, 5)
a.clear()
print(b) # (1, 2, 3, [], 4, 5)
a = [1]
print(b) # (1, 2, 3, [], 4, 5)
\end{python}
Click \href{https://pythontutor.com/visualize.html#code=a%20%3D%20%5B1,%202,%203%5D%0Ab%20%3D%20%281,%202,%203,%20a,%204,%205%29%0Aprint%28b%29%0Aa.clear%28%29%0Aprint%28b%29%0Aa%20%3D%20%5B1%5D%0Aprint%28b%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false}{\underline{here}} for full visualization.

\section{Question 4}
\begin{python}
# CS1010S AY18/19 Sem 2 Finals
a = [1, 2]
a += [a]
print(a) # [1, 2, [...]] <- this ellipsis means referring to itself
b = a.copy() # shallow copy vs deep copy?
a[2] = 0
print(a) # [1, 2, 0]
print(b) # [1, 2, [1, 2, 0]]
\end{python}
Click \href{https://pythontutor.com/visualize.html#code=a%20%3D%20%5B1,%202%5D%0Aa%20%2B%3D%20%5Ba%5D%0Aprint%28a%29%0Ab%20%3D%20a.copy%28%29%20%23%20shallow%20copy%20vs%20deep%20copy%3F%0Aa%5B2%5D%20%3D%200%0Aprint%28a%29%0Aprint%28b%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false}{\underline{here}} for full visualization.

\section{Question 5}
\begin{python}
a = [1, 2, 3]
b = [4, a]
c = [a, b, 15, b[0], b[1]]

c[1][0] = 99
print(b) # [99, [1, 2, 3]]
print(c) # [[1, 2, 3], [99, [1, 2, 3]], 15, 4, [1, 2, 3]]

c[3] = 100
print(b) # [99, [1, 2, 3]]
print(c) # [[1, 2, 3], [99, [1, 2, 3]], 15, 100, [1, 2, 3]]

a[1] = 200
print(a) # [1, 200, 3]
print(b) # [99, [1, 200, 3]]
print(c) # [[1, 200, 3], [99, [1, 200, 3]], 15, 100, [1, 200, 3]]

b[1][2] = 300
print(a) # [1, 200, 300]
print(b) # [99, [1, 200, 300]]
print(c) # [[1, 200, 300], [99, [1, 200, 300]], 15, 100, [1, 200, 300]]

d = [4, c.copy()]
c[2] = 500
c[0][2] = 500
print(d) # [4, [[1, 200, 500], [99, [1, 200, 500]], 15, 100, [1, 200, 500]]]
\end{python}
Click \href{https://pythontutor.com/visualize.html#code=a%20%3D%20%5B1,%202,%203%5D%0Ab%20%3D%20%5B4,%20a%5D%0Ac%20%3D%20%5Ba,%20b,%2015,%20b%5B0%5D,%20b%5B1%5D%5D%0A%0Ac%5B1%5D%5B0%5D%20%3D%2099%0Aprint%28b%29%0Aprint%28c%29%0A%0Ac%5B3%5D%20%3D%20100%0Aprint%28b%29%0Aprint%28c%29%0A%0Aa%5B1%5D%20%3D%20200%0Aprint%28a%29%0Aprint%28b%29%0Aprint%28c%29%0A%0Ab%5B1%5D%5B2%5D%20%3D%20300%0Aprint%28a%29%0Aprint%28b%29%0Aprint%28c%29%0A%0Ad%20%3D%20%5B4,%20c.copy%28%29%5D%0Ac%5B2%5D%20%3D%20500%0Ac%5B0%5D%5B2%5D%20%3D%20500%0Aprint%28d%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false}{\underline{here}} for full visualization.

\newpage

\section{Question 6}
\begin{python}
# CS1010X AY18/19 Special Term I Finals
a = [4, 3, 2, 1]
b = [1, 4, 3, 2]
c = [2, 1, 4, 3]
d = [3, 2, 1, 4]
a[0], a[1], a[2] = a, c, b
b[0], b[1], b[2] = a, b, c
c[0], c[1], c[2] = c, b, d
d[0], d[1], d[2] = c, d, a
print(a[0][1][0][2][1][2][2][2][3]) # 3
\end{python}
Click \href{https://pythontutor.com/visualize.html#code=a%20%3D%20%5B4,%203,%202,%201%5D%0Ab%20%3D%20%5B1,%204,%203,%202%5D%0Ac%20%3D%20%5B2,%201,%204,%203%5D%0Ad%20%3D%20%5B3,%202,%201,%204%5D%0Aa%5B0%5D,%20a%5B1%5D,%20a%5B2%5D%20%3D%20a,%20c,%20b%0Ab%5B0%5D,%20b%5B1%5D,%20b%5B2%5D%20%3D%20a,%20b,%20c%0Ac%5B0%5D,%20c%5B1%5D,%20c%5B2%5D%20%3D%20c,%20b,%20d%0Ad%5B0%5D,%20d%5B1%5D,%20d%5B2%5D%20%3D%20c,%20d,%20a%0Aprint%28a%5B0%5D%5B1%5D%5B0%5D%5B2%5D%5B1%5D%5B2%5D%5B2%5D%5B2%5D%5B3%5D%29&cumulative=false&curInstr=9&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false}{\underline{here}} for full visualization.

\section{Question 7: Minesweeper!}
In Minesweeper, we have some mines placed in a 2-D field (starting from row 0, column
0) and store the positions of these mines within a list. For instance, the grid below.
\begin{python}
grid = [["O","O","X","O"],  # row 0
        ["X","O","X","X"],
        ["O","X","O","O"]]  # row 2

bombs = [[0, 2], [1, 0], [1, 2], [1, 3], [2, 1]]
\end{python}
For the position at row 1 column 2, there are a total of 4 bombs in its vicinity. "Vicinity" in
minesweeper means the bombs in a 3-by-3 grid with respect to its position in the middle.
\begin{enumerate}[(a)]
\item Define a function \texttt{\bfseries grid\_to\_bombs} that takes in a grid as shown and returns the
bombs list, containing the positions of all the bombs found in the grid (marked as "X").
\textbf{Sample Test:}
\begin{python}
>>> grid_to_bombs(grid) == bombs
True
\end{python}
\textbf{Solution:}
\begin{python}
def grid_to_bombs(grid):
    bombs = []
    
    for row_num in range(len(grid)):
        for col_num in range(len(grid[0])):
            if grid[row_num][col_num] == "X":
                bombs.append([row_num, col_num])
    
    return bombs
\end{python}

\item Now, define a function \texttt{\bfseries count\_bombs} that takes in a row and a column, as well as a
grid, and returns the number of bombs in the vicinity of that row and column. \\
\textbf{Sample Test:}
\begin{python}
>>> count_bombs(1, 2, grid)
4
\end{python}
\textbf{Solution:}
\begin{python}
def count_bombs(row_num, col_num, grid):
    answer = 0
    top_bound = max(0, row_num - 1)
    left_bound = max(0, col_num - 1)
    right_bound = min(len(grid[0]), col_num + 2)
    down_bound = min(len(grid), row_num + 2)

    for r in range(top_bound, down_bound):
        for c in range(left_bound, right_bound):
            answer += int(grid[r][c] == "X")

    return answer
\end{python}
\end{enumerate}

\begin{flushright}
\vspace{2 cm}\textbf{\textit{Solution compiled by Russell Saerang.}}
\end{flushright}
\end{document}