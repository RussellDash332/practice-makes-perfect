\input ../../setup

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{tikz-qtree}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multicol}
\usepackage{xcolor}
\setlength{\columnsep}{5mm}

% \renewcommand{\labelenumi}{\alph{enumi}.}
% \renewcommand{\labelenumii}{(\roman{enumii})}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}


\lstdefinestyle{normalPy}{
language=Python,				% the language of the code
basicstyle=\footnotesize,			% the size of the fonts that are used for the code
numbers=left,				% where to put the line-numbers; possible values are (none, left, right)
numberstyle=\color{mygray},		% the style that is used for the line-numbers
stepnumber=1,				% the step between two line-numbers. If it's 1, each line will be numbered
numbersep=5pt,				% how far the line-numbers are from the code
backgroundcolor=\color{white},		% choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
showstringspaces=false,			% underline spaces within strings only
showspaces=false,				% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showtabs=false,				% show tabs within strings adding particular underscores
frame=shadowbox,				% adds a frame around the code
tabsize=4,					% sets default tabsize to 4 spaces
captionpos=t,				% sets the caption-position to bottom
breaklines=true,				% sets automatic line breaking
breakatwhitespace=false,			% sets if automatic breaks should only happen at whitespace
commentstyle=\color{mygreen},    	% comment style
keepspaces=true,                 		% keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue},       		% keyword style
}

\lstdefinestyle{consolePy}{
stepnumber=0,
}
\tikzset{every tree node/.style={minimum width=2em,draw,circle},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw, edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
         level distance=1.5cm}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\psetheader{Mock Finals}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\medskip

You have only \textbf{2 hours} to solve all \textbf{FIVE (5) questions}. \\
The maximum attainable score is \textbf{100}. Good luck! \\ \\
\textit{Prepared by Russell Saerang.}

\begin{multicols*}{2}
[
\section{Question 1: Python Expressions [30 marks]}
There are several parts to this problem. Answer each part \underline{\textbf{independently and separately}}. \\
In each part, the Python snippet is entered into a Python script and then run. Determine the
response printed by the interpreter (Python shell) and \textbf{write the exact output}. 
If the interpreter produces an error message, or enters an infinite loop, explain why and
\textbf{clearly state the responsible evaluation step}.
]
\begin{enumerate}
\item[\textbf{A.}] 
\begin{python}
a = [0, 1]
b = [[1], [[2]]]
b.extend(a)
print(b)
a.append(a)
print(b)
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}

\item[\textbf{B.}]
\begin{python}
d, msp = {}, "mississippi"
for x in msp:
    if x not in d:
        d[x] = 1
    else:
        d[x] += 1
        d[d[x]] = 1
print(d)
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}

\item[\textbf{C.}]
\begin{python}
kh, z = "kenghwee", "zoink"
sus = 0
for s in kh:
    if s in z:
        sus += 1
    if s == "e":
        print(sus)
    elif s > "k":
        sus *= 2
print(sus)
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}

\item[\textbf{D.}]
\begin{python}
def debug(s):
    try:
        return s + 123
    except ValueError:
        return str(s) + "123"
    except Exception:
        return "F"
    except:
        return "FF"
for q in ["Gday", 42, [0]]:
    print(debug(q))
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}

\item[\textbf{E.}]
\begin{python}
def bar(z):
    return lambda r: baz(r - 1) \
            if r > 5 else r + z
def baz(r):
    return lambda z: bar(z // 2) \
            if z > 0 else 5
print(baz(4)(100)(4))
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}

\item[\textbf{F.}]
\begin{python}
def p(p, q):
    print(p)
    return q(p + q(p))
def q(q):
    print(q)
    return q + q
print(p(2, q))
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}
\end{enumerate}
\end{multicols*}

\newpage
\section{Question 2: Plagiarism [28 marks]}
Ben Bitdiddle is back as a CS1010Z lecturer and he decided to investigate how the plagiarism checker works in the module! \\ \\
Suppose we represent an assessment's list of submissions with a list of answer data. Each answer data is represented as a 
\colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}} containing the \textbf{name} of the answer submitter, the \textbf{time} of 
submission (\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}, in HHMM format), and the \textbf{answer} (\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}) itself. \\
For example, suppose a question is answered by six people:
\begin{python}
answers = [
    ["Russell", "0930", "recursion"], ["Keng Hwee", "1020", "recursive"],
    ["Jonathan", "1021", "recurse"], ["Wei Han", "1100", "recursion"],
    ["Gerald", "1104", "recursion tree"], ["Hoi Yin", "1216", "recurse"]
]
\end{python}
\begin{enumerate}
\item[\textbf{A.}]
\textbf{[Warm-up]} One of the requirements for the plagiarism checker is the time difference between two submissions. Implement the 
function \colorbox{CornflowerBlue!20}{\texttt{minutes(time)}} that takes in a \textbf{string} (\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}) 
and returns the number of minutes that has passed since the first minute of the day. For example, \texttt{minutes("0912")} returns \texttt{552}.
\begin{flushright}
    [2 marks]
\end{flushright}

\item[\textbf{B.}]
Implement the function \colorbox{CornflowerBlue!20}{\texttt{get\_answer(answers, name)}} that takes as input an answers list 
(\colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}} of \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}}), and a \textbf{name} 
(\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}). Return \textbf{name}'s answer on the answers list. If \textbf{name} is not found, return 
\colorbox{CornflowerBlue!20}{\texttt{\textbf{None}}}.\\
Sample execution:
\begin{python}
>>> get_answer(answers, "Keng Hwee")
'recursive'
>>> get_answer(answers, "Gerald")
'recursion tree'
>>> get_answer(answers, "Pak")
None
\end{python}
\begin{flushright}
    [2 marks]
\end{flushright}

\item[\textbf{C.}]
Of course, it is possible for another students to submit their answer for the first time. Implement the function \colorbox{CornflowerBlue!20}{\texttt{submit\_answer(answers, name, time, answer)}} 
that takes as input an answers list (\colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}} of \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}}), a \textbf{name} 
(\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}), the \textbf{time} (\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}), and the \textbf{answer} 
(\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}). Modify the original answers list by adding the answer data to it. \\
You may assume the student has never submitted any answer before. \\
Sample execution:
\begin{python}
>>> submit_answer(answers, "Pak", "1247", "recursing")
>>> answers
[['Russell', '0930', 'recursion'], ['Keng Hwee', '1020', 'recursive'],
 ['Jonathan', '1021', 'recurse'], ['Wei Han', '1100', 'recursion'],
 ['Gerald', '1104', 'recursion tree'], ['Hoi Yin', '1216', 'recurse'],
 ['Pak', '1247', 'recursing']]
\end{python}
\begin{flushright}
    [4 marks]
\end{flushright}

\item[\textbf{D.}]
Since we can implement a function to submit an answer, why not resubmitting an answer? \\
Implement the function \colorbox{CornflowerBlue!20}{\texttt{resubmit\_answer(answers, name, time, answer)}} 
that takes as input an answers list (\colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}} of \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}}}), a \textbf{name} 
(\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}), the new \textbf{time} (\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}), and the new \textbf{answer} 
(\colorbox{CornflowerBlue!20}{\texttt{\textbf{str}}}). Modify the original answers list by modifying the correct answer data. You may assume the student has already 
submitted an answer before. \\
Sample execution:
\begin{python}
>>> resubmit_answer(answers, "Russell", "1316", "iterative")
>>> answers
[['Russell', '1316', 'iterative'], ['Keng Hwee', '1020', 'recursive'],
 ['Jonathan', '1021', 'recurse'], ['Wei Han', '1100', 'recursion'],
 ['Gerald', '1104', 'recursion tree'], ['Hoi Yin', '1216', 'recurse']]
\end{python}
\begin{flushright}
    [4 marks]
\end{flushright}

\item[\textbf{E.}]
Now that we have handled incoming submissions, it's time for us to handle the current submissions. For now, CS1010Z's plagiarism technology is quite simple and 
therefore we are going to build it from scratch. \\
First, implement the function \colorbox{CornflowerBlue!20}{\texttt{similarity\_score(str1, str2)}} that calculates the similarity score 
between two strings as follows:
\begin{itemize}
\item Ignore spacings on both strings, meaning \texttt{"bob cat"} is treated the same way as \texttt{"bobcat"}. This step will produce two new strings.
\item If the new \colorbox{CornflowerBlue!20}{\texttt{str1}} is longer than the new \colorbox{CornflowerBlue!20}{\texttt{str2}}, then return the proportion of letters of the new 
\colorbox{CornflowerBlue!20}{\texttt{str2}} that are in the same position as the new \colorbox{CornflowerBlue!20}{\texttt{str1}}. Otherwise return the proportion of letters of the new 
\colorbox{CornflowerBlue!20}{\texttt{str1}} that are in the same order as the new \colorbox{CornflowerBlue!20}{\texttt{str2}}.
\end{itemize}
You may assume both strings are in low-capitalized. \\
Sample execution:
\begin{python}
>>> similarity_score("iteration", "iterative")
0.7777777777777778
>>> similarity_score("iteration is cool", "iterator is fun")
0.46153846153846156 # 6 out of 13 matches ("iterat")
\end{python}
\begin{flushright}
    [6 marks]
\end{flushright}

\item[\textbf{F.}]
After implementing the similarity scoring, we are just a method away from determing the suspects! \textbf{Using the previously defined functions}, 
implement a function \colorbox{CornflowerBlue!20}{\texttt{blame(answers, name1, name2)}} that takes in two \textbf{distinct names inside the answers list} and verifies 
whether both names are involved in plagiarism. Return \texttt{\bfseries True} if the time difference between both submissions is less than an hour and the similarity 
score on the answers is at least 0.8, otherwise return \texttt{\bfseries False}. \\
\textit{You will be heavily penalized if you do not use the function defined in the previous parts but you could have.} \\
Sample execution:
\begin{python}
>>> blame(answers, "Russell", "Wei Han")
False
>>> blame(answers, "Keng Hwee", "Jonathan")
True
\end{python}
\begin{flushright}
    [6 marks]
\end{flushright}

\item[\textbf{G.}]
Ben Bitdiddle finally figured out what's wrong with the current implementation of the plagiarism checker. Suppose Jonathan decides to resubmit 
the exact same answer again:
\begin{python}
>>> blame(answers, "Jonathan", "Keng Hwee")
True
>>> resubmit_answer(answers, "Jonathan", "1700", \
        get_answer(answers, "Jonathan"))
>>> blame(answers, "Jonathan", "Keng Hwee")
False
\end{python}
This will implicitly free Keng Hwee from the plagiarism blaming, which of course does not make any sense. \\
Suggest an improvement on the representation such that regardless of resubmission, a student is still flagged for plagiarism due to his/her 
past answers.
\begin{flushright}
    [4 marks]
\end{flushright}
\end{enumerate}

\newpage
\section{Question 3: Terminal Trauma [21 marks]}
After looking at the CS1010S Trauma Support Group chat, you became bored and decided to open your terminal. However, 
you began to realize that dictionaries are haunting you inside it. \\ \\
Suppose we model a terminal's home directory with a dictionary of dictionaries where the keys are either file names or directory names 
and the values are \texttt{\bfseries None} if the key is a file name and a dictionary otherwise, which may contain more files and directories. \\
For example, the home directory below contains one file and two directories containing more files.
\begin{python}
>>> home = {
        'a.py': None,
        'b': {
            'd.py': None,
            'e.py': None,
        },
        'c': {
            'f.py': None,
            'g': {
                'i.py': None,
                'j.java': None
            },
            'h': {} # empty directory
        }
    }
\end{python}
\begin{enumerate}
\item[\textbf{A.}]
One of the most useful command inside the terminal is \texttt{\bfseries cd}, where you can \textbf{c}hange your 
current working \textbf{d}irectory from one to another. \\
Implement the function \colorbox{CornflowerBlue!20}{\texttt{cd(directory, path)}} that takes in a dictionary 
\texttt{\bfseries directory} representing a directory and a string \texttt{\bfseries path} representing the path 
where you want to go. \\
Note that \texttt{\bfseries path} is a series of directories that you want to go to, separated by a \texttt{\bfseries "/"} 
and always ends with a \texttt{\bfseries "."} to indicate the end of traversal. \\
You may assume that the given input is a valid path. \\ \\
Sample execution:
\begin{python}
>>> cd(home, "c/.")
{'f.py': None, 'g': {'i.py': None, 'j.java': None}, 'h': {}}
>>> cd(home['b'], ".")
{'d.py': None, 'e.py': None}
>>> cd(home, "c/g/.")
{'i.py': None, 'j.java': None}
\end{python}
\begin{flushright}
    [4 marks]
\end{flushright}

\item[\textbf{B.}]
Explain the order of growth in terms of \textbf{time} of the function \colorbox{CornflowerBlue!20}{\texttt{cd(directory, path)}} that 
you have implemented previously.
\begin{flushright}
    [2 marks]
\end{flushright}

\item[\textbf{C.}]
Besides changing your current working directory, you can rename a file as well. Implement the function 
\colorbox{CornflowerBlue!20}{\texttt{rename(directory, path, old\_name, new\_name)}} that takes in a dictionary \texttt{\bfseries directory} representing a directory, 
a string \texttt{\bfseries path} representing the path, and two strings \texttt{\bfseries old\_name} and \texttt{\bfseries new\_name} for the files that you want its 
name to change. Simply rename the file name into the new name by modifying the directory itself. \\
You may assume that the given input is a valid path. \\ \\
Sample execution:
\begin{python}
>>> rename(home, "c/g/.", "i.py", "j.java")
>>> cd(home, "c/g/.")
{'i.py': None, 'j.java': None} # nothing happens
>>> rename(home, "c/g/.", "i.py", "k.py")
>>> cd(home, "c/g/.")
{'j.java': None, 'k.py': None}
>>> rename(home, "c/g/.", "i.py", "l.py")
>>> cd(home, "c/g/.")
{'j.java': None, 'k.py': None} # i.py doesn't exist anymore
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}

\item[\textbf{D.}]
Implement the function \colorbox{CornflowerBlue!20}{\texttt{copy(directory, path, new\_path)}} that takes in a dictionary \texttt{\bfseries directory} representing a directory, 
a string \texttt{\bfseries path} representing the path, and a string \texttt{\bfseries new\_path} for the new path. Copy all the contents of the old directory to the new directory. \\ 
You may assume the new directory is never contained inside the old directory. There's a reason for this assumption and you may ponder about it for the bonus part. \\ \\
Sample execution:
\begin{python}
>>> copy(home, "c/g/.", ".")
>>> home
{
    'a.py': None,
    'b': {
        'd.py': None,
        'e.py': None
    },
    'c': {
        'f.py': None,
        'g': {
            'i.py': None,
            'j.java': None
        },
        'h': {}
    },
    # It's copied!
    'i.py': None, 'j.java': None
}
# BONUS PART
>>> copy(home, ".", "c/.") # what will happen?
\end{python}
\begin{flushright}
    [5 + 2 marks]
\end{flushright}

\item[\textbf{E.}]
Implement the function \colorbox{CornflowerBlue!20}{\texttt{move(directory, path, new\_path)}} that takes in a dictionary \texttt{\bfseries directory} representing a directory, 
a string \texttt{\bfseries path} representing the path, and a string \texttt{\bfseries new\_path} for the new path. Move all the contents of the old directory to the new directory. \\
Similarly, you may assume the new directory is never a proper subset of the old directory and that the given input is a valid path. \\ \\
Sample execution:
\begin{python}
>>> cd(home, "c/.")
{'f.py': None, 'g': {'i.py': None, 'j.java': None}, 'h': {}}
>>> move(home, "c/g/.", ".")
>>> home
{
    'a.py': None,
    'b': {
        'd.py': None,
        'e.py': None
    },
    'c': {
        'f.py': None,
        'g': {}, # g is now an empty directory
        'h': {}
    },
    # It's moved!
    'i.py': None,
    'j.java': None
}
>>> move(home, ".", ".")
>>> home # nothing changes
{
    'a.py': None,
    'b': {
        'd.py': None,
        'e.py': None
    },
    'c': {
        'f.py': None,
        'g': {},
        'h': {}
    },
    'i.py': None,
    'j.java': None
}
>>> move(home, "c/.", "c/.") # similarly, nothing should happen
>>> cd(home, "c/.")
{'f.py': None, 'g': {}, 'h': {}}
\end{python}
\begin{flushright}
    [5 marks]
\end{flushright}
\end{enumerate}

\newpage
\section{Question 4: Cells at Work! [17 marks]}
Consider the following classes.
\begin{python}
class Cell:
    def __init__(self, health, damage):
        self.health = min(100, health)
        self.damage = damage
        self.dead = False

    def regenerate(self):
        self.health = min(100, self.health + 20)

class RedBloodCell(Cell):
    def __init__(self, health, damage, utility):
        super().__init__(health, damage)
        self.utility = utility

    def regenerate(self):
        self.health = min(100, self.health + 30 * self.utility)
\end{python}

\begin{enumerate}
\item[\textbf{A.}]
What will be output of executing the following lines:
\begin{python}
>>> blood = RedBloodCell(40, 0, 1.3)
>>> blood.health

>>> blood.regenerate()
>>> blood.health

>>> blood.attack(Cell(100, 1))
>>> blood.regenerate()
>>> blood.health
\end{python}
\begin{flushright}
    [2 marks]
\end{flushright}

\item[\textbf{B.}]
Wilson decides to create a dead red blood cell as follows. However, he finds something weird because dead cells cannot regenerate anymore.
\begin{python}
>>> dead_blood = RedBloodCell(0, 0, 1.5)
>>> dead_blood.health
0
>>> dead_blood.regenerate()
>>> dead_blood.health
45.0
\end{python}
Explain why does the dead cell still regenerate and modify the code above to fix this issue according to OOP principles, i.e. 
redundant code will be penalised.
\begin{flushright}
    [4 marks]
\end{flushright}

\item[\textbf{C.}]
A \colorbox{CornflowerBlue!20}{\texttt{\textbf{WhiteBloodCell}}} is also a special type of cell. Constructed by only its damage and utility, it is always created 
with 30 health and it regenerates just like a red blood cell but everytime it does, its utility increases by 10\% of its original utility. Moreover, it can attack 
cells other than itself as long as its own health is at least 50.
\begin{itemize}
\item If the attack is successful, the target cell's health will be decreased by \textbf{the product between the white blood cell's damage and utility}. Additionally, 
if the target cell is a red blood cell, its utility will be decreased by 30\% of the original utility.
\item If the target cell's health is less than the damage taken, it simply dies.
\item Finally, if the attack is a success, print \texttt{\bfseries "Cell attacked!"}. Otherwise, print \texttt{\bfseries "Cell needs to regenerate..."}.
\end{itemize}
Sample execution:
\begin{python}
>>> U1146 = WhiteBloodCell(40, 1.5)
>>> ordinary = Cell(30, 1)
>>> U1146.attack(U1146)     # nothing happens
>>> U1146.attack(ordinary)
'Cell needs to regenerate...'
>>> ordinary.health
30                          # ordinary is still in full health
>>> U1146.regenerate()
>>> U1146.attack(ordinary)
'Cell attacked!'
>>> ordinary.health
0                           # ordinary is dead

>>> U1147 = WhiteBloodCell(40, 1.5)
>>> AE3803 = RedBloodCell(80, 0, 1.2)
>>> U1147.regenerate()      # utility is now 1.65
>>> U1147.attack(AE3803)
'Cell attacked!'
>>> AE3803.health
14.0                        # 80 - 40 * 1.65
>>> AE3803.utility
0.84                        # 1.2 * 0.7
\end{python}
Provide an implementation of the class \colorbox{CornflowerBlue!20}{\texttt{\textbf{WhiteBloodCell}}} using OOP principles. Redundant code or methods will be 
penalised.
\begin{flushright}
    [6 marks]
\end{flushright}

\item[\textbf{D.}]
Right after implementing a white blood cell, Wilson decides to implement the class \colorbox{CornflowerBlue!20}{\texttt{\textbf{CancerCell}}} as follows:
\begin{python}
class CancerCell(RedBloodCell, WhiteBloodCell):
    pass
\end{python}
Now he decides to try the implementation out with a few tests.
\begin{python}
>>> cancer = CancerCell(100, 1000, 1.7)
>>> skin = Cell(50, 1)
>>> cancer.attack(skin)
'Cell needs to regenerate...'
\end{python}
Something's wrong! The cancer cell is supposed to even kill the skin cell. Explain why the mistake happens 
and suggest a fix by modifying the code based on OOP principles.
\begin{flushright}
    [5 marks]
\end{flushright}
\end{enumerate}

\section{Question 5: 42 and the Meaning of Life [4 marks]}
Either:
\begin{enumerate}[(a)]
    \item explain how you think some of what you have learnt in CS1010S will be helpful for
    you for the rest of your life and/or studies at NUS;
    \item tell us an interesting story about your
    experience with CS1010S this semester;
    \item share how the COVID 19 situation has positively
    influenced/impacted your learning in CS1010S;
    \item \textbf{how the CS1010S Trauma Support Group has been full of memes}.
\end{enumerate}
\subsection{Remark}
\textbf{The marking scheme is always like this.} \\ \\
The student will be awarded points as long as he/she is coherent and doesn’t say something
obviously wrong. \\ \\
This question is designed for students who get stuck with the other questions. They can at
least spend some time writing an essay for marks. Points will be awarded for effort. \\ \\
Make the prof laugh out loud and you get full marks.

\newpage
\section{Appendix}
Parts of the Python documentation is given here for your reference.
\subsection{List Methods}
\begin{itemize}
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.append(x)}} Add an item to the end of the list.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.extend(iterable)}} Extend the list by appending all the items from the iterable.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.insert(i, x)}} Insert an item at a given position.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.remove(x)}} Remove the first item from the list whose value is $x$. It is an error if
there is no such item.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.pop([i])}} Remove the item at the given position in the list, and return it. If no
index is specified, removes and returns the last item in the list.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.clear()}} Remove all items from the list
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.index(x)}} Return zero-based index in the list of the first item whose value is $x$.
Raises a \colorbox{CornflowerBlue!20}{\texttt{ValueError}} if there is no such item.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.count(x)}} Return the number of times $x$ appears in the list.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.sort(key=None, reverse=False)}} Sort the items of the list in place.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.reverse()}} Reverse the elements of the list in place.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{list}.copy()}} Return a shallow copy of the list.
\end{itemize}

\subsection{Dictionary Methods}
\begin{itemize}
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.clear()}} Remove all items from the dictionary.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.copy()}} Return a shallow copy of the dictionary.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.items()}} Return a new view of the dictionary’s items 
(\colorbox{CornflowerBlue!20}{\texttt{(key, value)}} pairs).
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.keys()}} Return a new view of the dictionary’s keys.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.pop(key[, default])}} If \textit{key} is in the dictionary, remove it and return its value,
else return \textit{default}. If \textit{default} is not given and \textit{key} is not in the dictionary, a 
\colorbox{CornflowerBlue!20}{\texttt{KeyError}}
is raised.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.update([other])}} Update the dictionary with the key/value pairs from other,
overwriting existing keys. Return \colorbox{CornflowerBlue!20}{\texttt{None}}.
\item \colorbox{CornflowerBlue!20}{\texttt{\textbf{dict}.values()}} Return a new view of the dictionary’s values.
\end{itemize}
\end{document}